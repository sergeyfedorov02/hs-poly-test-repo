module Part3.Tasks where

import Util (notImplementedYet)
import Data.List (maximumBy, group, sort, nub)
import Data.Ord (comparing)

-- Функция finc принимает на вход функцию f и число n и возвращает список чисел [f(n), f(n + 1), ...]
finc :: (Int -> a) -> Int -> [a]
finc f n = f n : finc f (n + 1)

-- Функция ff принимает на вход функцию f и элемент x и возвращает список [x, f(x), f(f(x)), f(f(f(x))) ...]
ff :: (a -> a) -> a -> [a]
ff f x = x : ff f (f (x))

-- Дан список чисел. Вернуть самую часто встречающуюся *цифру* в этих числах (если таковых несколько -- вернуть любую)
mostFreq :: [Int] -> Int
mostFreq numbers =
  -- Преобразуем входной массив из чисел в одну строку из этих чисел:
    -- show - преобразование каждого числа в строку ([42] -> ["42"])
    -- concatMap - преобразуем список из строк в одну большую строку, состоящую из отдельных цифр (["42"] -> ["4", "2"])
  let digits = concatMap (show) numbers
      -- Отсортируем полученную строку по возрастанию и далее объединим одинаковые цифры
        -- sort - сортировка по возратсанию (["4", "2", "6", "2"] -> ["2", "2", "4", "6"])
        -- group - группировка одинаковых в отедельные списки (["2", "2", "4", "6"] -> [["2", "2"], ["4"], ["6"]])
      groupedDigits = group $ sort digits
      -- Найдем самый большой по длине из полученных на предыдущем шаге подсписков
        -- (comparing length) - на основании чего будет применен maximumBy, то есть
        -- на основании длин подсписков выберем самый большой при помощи maximumBy ([["2", "2"], ["4"], ["6"]] -> ["2", "2"])
      mostFrequentDigitGroup = maximumBy (comparing length) groupedDigits
      -- Возьмем первый элемент из полученного массива (["2", "2"] -> "2")
      mostFrequentDigit = head mostFrequentDigitGroup
  -- Преобразуем найденную цифру из строки в число и вернем в качестве результата ("2" -> 2)
  in read [mostFrequentDigit]

-- Дан список lst. Вернуть список элементов из lst без повторений, порядок может быть произвольным.
uniq :: (Eq a) => [a] -> [a]
-- Воспользуемся функцией nub для удаления всех повторяющихся элементов
uniq = nub

-- Функция grokBy принимает на вход список Lst и функцию F и каждому возможному
-- значению результата применения F к элементам Lst ставит в соответствие список элементов Lst,
-- приводящих к этому результату. Результат следует представить в виде списка пар.
grokBy :: (Eq k) => (a -> k) -> [a] -> [(k, [a])]
grokBy _ [] = []
-- Извлекаем key из первого элемента X и формируем пару (key, group), которая окажется в начале списка
-- Затем рекурсивно вызываем это же для оставшейся части
grokBy f (x:xs) = (key, group) : grokBy f remaining
    where
      -- key - результат применения функции F к элементу X
      key = f x
      -- group - это список с головой равной X и содержит все элементы XS, которые имеют тот же ключ, что и X
      group = x : filter (\el -> f el == key) xs
      -- remaining - это оставшиеся элементы списка, у которых ключ не такой, как у X
      remaining = filter (\el -> f el /= key) xs
